<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catch me code]]></title>
  <link href="http://jonaslu.github.com/atom.xml" rel="self"/>
  <link href="http://jonaslu.github.com/"/>
  <updated>2013-04-24T22:17:12+02:00</updated>
  <id>http://jonaslu.github.com/</id>
  <author>
    <name><![CDATA[Jonas Lundberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The next big language]]></title>
    <link href="http://jonaslu.github.com/blog/2013/04/24/the-next-big-language/"/>
    <updated>2013-04-24T21:57:00+02:00</updated>
    <id>http://jonaslu.github.com/blog/2013/04/24/the-next-big-language</id>
    <content type="html"><![CDATA[<p>This is a hot topic, there&#8217;s no shortage of blog posts already. So all the reason for me to join in and throw my prediction in the pile.</p>

<p>But first a trip down memory lane. The first language used in teaching I encountered was <a href="http://en.wikipedia.org/wiki/Pascal_(programming_language%29">Pascal</a>. The more I&#8217;ve thought about it the more it stands that this was for a good reason. Pascal had strictness on form built into the language. Turns out this even had a name wich I didn&#8217;t know about - <a href="http://en.wikipedia.org/wiki/Structured_programming">structured programming</a>.</p>

<h2>Why Pascal was used</h2>

<p>There was more to Pascal besides the actual mechanics of programming - to emphasize structure and form. In the small you were given your first lesson in how to successfully communicate your ideas through code. Most probably this was only to your teacher for passing the assignments or for your future self revisiting the code some months down the line. But it was an important first lesson.</p>

<h2>Java/C# is the Pascal of the industry</h2>

<p>The much cursed verbosity of these languages are actually IMHO their reason for making it as an industrial language. They force you to flesh out more on your intent and expose more details (that&#8217;s where the devil hides) of your ideas. More typing for you - but more benefits for the large team or corporation.</p>

<p>I think this is why javascript is having a resurgence and why node.js has been so successful - the introduction of the module pattern and that variables and functions are hoisted to the top of each function. It&#8217;s really a blessing in disguise because you&#8217;re now forced by <a href="http://en.wikipedia.org/wiki/Douglas_Crockford">Crockford</a> via <a href="http://www.jslint.com/">jslint</a> to declare variables in the top of the function. This helps clear up intentions. Same goes with the module pattern. You&#8217;re more bound to one common form and others can more easily spot what you&#8217;re trying to convey.</p>

<p>Java has this built in - you&#8217;re forced to follow a pretty strict pattern when writing code. Perl does not and I&#8217;m thinking this is why it hasn&#8217;t been used that much for large projects despite being around for so long. Its good for the one-off scripts that you and a few of you&#8217;re colleagues on the same team will read. But if you scale it up - there&#8217;s <a href="http://perl.plover.com/obfuscated/">too much freedom</a> or rather too much room for personal style. Ideas will be hard to convey unless everyone agrees on a formal standard and what better way to enforce a standard than built into a language?</p>

<h2>The form should help collaboration</h2>

<p>Every new programming language that&#8217;s coming out is touting type less get more done as its main selling point. Its an amicable aim to reduce the amount of code having to be written since bugs tend to correlate with the lines of code. There will be abundant examples of how you can write this or that problem in so few lines of code compared to that language. All good so far, its got to start somewhere and you the programmer is its main target for adoption.</p>

<p>But how few lines of code you can write something isn&#8217;t really a good gauge of a new language. How well someone can understand your intent of the code you wrote is much more so. Remember that you&#8217;re seldom writing code for yourself but most of it for others (or your future self that tends to forget what that so compact one liner really meant).</p>

<p>This has to be if not more important than at least as important as reducing the lines of code. The reduction should only be made if the intent and message is still as clear sans the lines reduced.</p>

<h2>The next big language</h2>

<p>My bet is that it will be strict on form and structure. It maybe will reduce the lines of code somewhat, but not by as much as you&#8217;d hope for - because transparency cannot be sacrificed for terseness. It just won&#8217;t work across larger code bases and teams.</p>

<p>I think it won&#8217;t be decided by you the programmer as much as it will be decided by teams trying to get stuff done. In true pragmatic fashion lanugages that do not convey the message clearly enough will be thrown out in favour for languages that do. Call it democracy by pragmatism.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If it weren't for the ... customers]]></title>
    <link href="http://jonaslu.github.com/blog/2013/03/24/if-it-werent-for-the-dot-dot-dot-customers/"/>
    <updated>2013-03-24T21:52:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/03/24/if-it-werent-for-the-dot-dot-dot-customers</id>
    <content type="html"><![CDATA[<p>I&#8217;ve had the luxury of being on a team having a dedicated code base to only one target user. Sure, that user has some different groupings within - but on the whole its coherent enough to see it as one customer. We&#8217;re basically free to model the software after this one customer. Its been a hot bed for invention and full speed development (in a good way).</p>

<p>For the sake of taxonomy - here&#8217;s what I mean by a target user: If Bob and Alice both are accountants they might be one target user. It depends on if they have the roughly the same workflow and crunch roughly the same numbers. Then they&#8217;re one target user. In all other situations they&#8217;re  two (specially if Alice is really a welder).</p>

<h2>Let&#8217;s share!</h2>

<p>So it came up for discussions with the business side this week that it would be benificial to bring other customers into the fold. I&#8217;m really split on this. I guess I can see the business benefits of it. We can now make an active pitch to a new segment of customers. But the thing is we&#8217;ve come from just that. We took the product from a 30+ different customers in the same code base and branched out. And we&#8217;ve cleaned and thrown out things to make it manageable thusly transforming it into the need of this one customer. Now the product looks different enough from where we started to be marketed to a new group of customers.</p>

<h2>The dilemma of good software</h2>

<p>There&#8217;s some kind of paradox - the best software naturally appeals and serves the most people. It would be rather pointless to put hours of work into something that only a few can use. Its supposed to help folks, preferably lots. But lots of people means lots of compromises and complexity which equals bugs. And buggy software isn&#8217;t good for your sanity or for your customers satisfaction. The only good way to reduce bugs is to reduce complexity (= code), but then it will appeal and help less people.  My take is that the sweet spot lies much farther on the one target user side. Here&#8217;s why:</p>

<h2>Limit the scope of target users</h2>

<p>If you have a low target user count you can tailor it to their exact needs. You&#8217;ll help fewer people but in return you can help these fewer people extremely well. And your software will be more stable and malleable into what they need. Code can be cleaned and optimized much harder because its not going to affect someone else.</p>

<p>With several target users in the same code base - things may superficially look the same - but in detail turns out to most often not be. If Bob does income and Alice does asset accounting it might on the surface look like they&#8217;re doing the same things (moving numbers around) but in detail its different numbers moving in different ways. And that is solved by either compromising - both gets less then what they wanted - or you raise the complexity (and bug count) by making it essentially two pieces of software in the same code base.</p>

<h2>But is this practical?</h2>

<p>No. Of course not. You have to accept some compromises and some ifdefs on sections in the code. Even with one target customer its going to happen. But strive to keep it as low as possible. This is of course from a coders standpoint. From a business standpoint I guess more target users in the same code base means you serve more with less effort. You can target groups that are similar saying &#8220;look here, we&#8217;re no 1 in accounting software with all these fine customers already on board. Join us, we&#8217;ll make it fit for you&#8221;. But its a curse in disguise because you also give lip service and raise the bug count for all target users already sharing the code base by making it fit one more.</p>

<p>I&#8217;d err more on the great customized and tailored service with less bugs and more shared ideas approach. I also think that shared code base will dampen creativity and exploration of pushing the software in new directions. And that in turn means missed business opportunities in helping your most important customer - the returning kind.</p>

<h2>Let&#8217;s share ideas! Not code (base)</h2>

<p>Ideas are cool in that they are not fixed in form. One idea carries some concept that may or may not apply. But it can be fuzzy on the details which can be filled out to fit the specific situation. And it can spark new ideas that fit better.</p>

<p>Shared code base is fixed in form. More than stake holder is depending on it being the same way. If someone wants to evolve it or break from it, all target users have to agree on this - otherwise you&#8217;re stuck. I&#8217;m not saying don&#8217;t ever share code. Do share code.. as a means to share ideas. But don&#8217;t share code mechanically just by saving a few keystrokes or fixing bugs faster (because on the flip side you&#8217;re probably introducing bugs faster too). Instead at each turn consider branching out a very possible option. Abandon the safe what is for the more exciting what could be.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boredom the hidden asset]]></title>
    <link href="http://jonaslu.github.com/blog/2013/03/16/boredom-the-hidden-asset/"/>
    <updated>2013-03-16T21:50:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/03/16/boredom-the-hidden-asset</id>
    <content type="html"><![CDATA[<p>I&#8217;ve been fighting boredom and procrastination for as long as I can remember.</p>

<h2>Boredom on personal projects</h2>

<p>Ah, new stuff. Fresh, untouched, exciting - and safely without practical use. Boredom and procrastination usually sets in when the first road block is hit. Like actually writing lines of code in that new language. Or using the long researched best web framework. And it results in more research and more looking at new things. Seldom staying long enough with something to make it useful.</p>

<h2>Moving is not a solution</h2>

<p>Same went for my workplace - I&#8217;d be all over it the first few months or even up to a year or two. Then when progression started to slow down - I knew the sites and the layout of the code its shininess faded and - hello boredom again!</p>

<p>Previously working as a consultant this didn&#8217;t turn into a problem since I changed workplaces often enough to keep things new and fresh. But this wasn&#8217;t really a solution on the problem, it was simply running away from it.</p>

<h2>Neither are processes</h2>

<p>So, true to engineer fashion I looked for remedies in the shape of processes and tools. I tried task lists, pomodoro, time boxing to name a few. This usually started out well but when the new effect wore off - about the same or more procrastination. And in the back of my mind I couldn&#8217;t help but think that all of those processes seemed too rigid. It was forcing it.</p>

<h2>Blog post to the rescue</h2>

<p><a href="http://99u.com/articles/7188/why-boredom-is-good-for-your-creativity">This hit me like a two ton heavy thing</a> (yes there&#8217;s probably some irony in finding the solution out there in a blog, the siren song of procrastination). To sum it up: It&#8217;s ok to be bored. In fact - if you&#8217;re bored and it&#8217;s the right kind of bore you are on to something big.</p>

<h2>Preparing to climb</h2>

<p>So I decided to work it. To leverage boredom instead of trying to suppress it.</p>

<p>The setup was this: close all the usual suspects. No mail notification icons, no rss feeds, no open  applications except for the minimal amount really needed to get the work done. Don&#8217;t minimize the windows. Close them. Deinstall what you can. You need to implement it the hard way and really maximize the potential for boredom.</p>

<p>Now sit there and let the boredom set in. Look at the code, stare at it. Don&#8217;t leave your workplace for anything less than critical. Do not open any mail clients or the likes. Gorge on boredom&#8230; and waaaaiiit for it.</p>

<h2>Downhill sunny side</h2>

<p>Past this point was a bit like that monkey meeting Jane Goodall. She just stood there and didn&#8217;t run away. What now?</p>

<p>Turns out boredom is a hill you&#8217;re meant to climb. The steeper the climb up, the sweeter the ride down. You eventually start to tinker in small pieces. And then in larger pieces, and before you know it you&#8217;re totally emerged in what you wanted to avoid.  Beyond that hill of boredom is the pot of voluntary productiveness.</p>

<p>On this side you&#8217;ll be glad you deinstalled all those notifiers and closed all those windows with sweet sugary distraction. You&#8217;re in the productivity zone cruising - but it&#8217;s a fragile zone. Any  distraction will break your concentration and you need to go through the build up phase again.</p>

<h2>Boredom as an innovator</h2>

<p>Here&#8217;s a bonus I didn&#8217;t see coming from this. When hitting boredom full on and closing down the distractions you get annoyed by manual and slow things. You know, the build window where you&#8217;d check your twitter account only to notice the build finished 15 minutes ago. Those hurt much more now because you&#8217;re now in productive mode after being bored you don&#8217;t want to go back - so you automate and innovate to minimize the mundane and time consuming parts.</p>

<h2>Switched tables</h2>

<p>Wow. How&#8217;s that for a flip side? Turns out boredom is not a liability - it&#8217;s an asset. And a valuable one at that. Its your personal indicator of how much you&#8217;re going to enjoy the task once the resistance subdues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom syntax in pygments]]></title>
    <link href="http://jonaslu.github.com/blog/2013/03/02/custom-syntax-in-pygments/"/>
    <updated>2013-03-02T21:29:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/03/02/custom-syntax-in-pygments</id>
    <content type="html"><![CDATA[<p>Guide to get started with a new syntax or tweaking an existing one in pygments.</p>

<h2>Background</h2>

<p>As said in <a href="http://www.catchmecode.com/blog/2013/02/18/fantom-the-language/">this</a> post I&#8217;m gonna cover Fantom a wee bit since I really like it. But alas! <del>There is no builtin code highlight for Fantom (yet :) in octopress.</del></p>

<p>Edit: Turns out that there actually is support since pygments 1.5 thanks to <a href="https://bitbucket.org/ivan_inozemtsev">Ivan Inozemtsev</a> (one of the folks behind the <a href="http://www.xored.com/products/f4/">f4 IDE</a>), its just not listed in their <a href="http://pygments.org/languages/">list of languages</a> and it resides in the compiled.py file, not the jvm.py file as you might expect. Still this post might serve as a springboard if you want to tweak the syntax of existing languages or introduce new languages.</p>

<h2>Pygments, whaaa?</h2>

<p>Although octopress runs on ruby it&#8217;s using the python library <a href="http://pygments.org/">pygments</a> as its code syntax highlighter. As does <a href="https://github.com/mojombo/jekyll">jekyll</a> the github markdown generator which octopress was born out of. A python in the ruby jungle? Probably because pygments aldready has a huge support for different languages - so its already got momentum.</p>

<p>Pygments turns source code to markup (or other formats - lots supported) by parsing the contents into tokens and applying different CSS styles to different tokens. The code becomes more readable and looks more like it would in an IDE. Pygments does this via <a href="http://pygments.org/docs/lexerdevelopment/">lexers</a> - essentially a large regex matched against code that emits different categorizations of the tokens.</p>

<h2>Installing pygments</h2>

<p>Python comes with its own package manager and build tools kit called <a href="http://peak.telecommunity.com/DevCenter/setuptools">setuptools</a>. This is available in the ubuntu repos so to install it type:</p>

<figure class='code'><figcaption><span>Install setuptools:</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install python-setuptools
</span></code></pre></td></tr></table></div></figure>


<p>Next up we install pygments itself using easy_install that comes with the now installed setuptools</p>

<figure class='code'><figcaption><span>Install pygments highlighter</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo easy_install Pygments
</span></code></pre></td></tr></table></div></figure>


<p>Pygments enables custom plugins via something called <a href="http://pygments.org/docs/plugins/#entrypoints">entrypoints</a> in setuptools. In this post I can swiftly move on to how you enable an entrypoint - but when reading this the first time I was stumped. What? Setuptools.. uhm ok. Entrypoints, right&#8230; pygments docs kind of went dead there assuming some python knowledge on the readers part. It took me quite a while of googling to understand what setuptools was and how you use entrypoints.</p>

<p>What it sums up to is that setuptools is a build and distribution kit for python which can create a distributable called an egg (I get it, a python lays binary distributable units.. very clever). Entry points are hooks that allow an egg to hook into an existing framework - essentially extending it with functionality later on.</p>

<h2>Module structure</h2>

<p>So, lets create an egg to hook our new lexer into pygments.</p>

<p>This can probably be done in more way than this, but from what I got working the module needs something like this as a directory structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>|- FantomLexer
</span><span class='line'>   |- fantomlexer
</span><span class='line'>   |  |- __init__.py
</span><span class='line'>   |  |- lexer.py
</span><span class='line'>   |- setup.py
</span></code></pre></td></tr></table></div></figure>


<p>The <code>__init__.py</code> file can be empty but it needs to be there so its enough to simply touch it. The <code>lexer.py</code> will contain the regex lexer for pygments.</p>

<p>The contents of the <code>setup.py</code> goes as following:</p>

<figure class='code'><figcaption><span>Contents of an entry point into pygments setup</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
</span><span class='line'>
</span><span class='line'><span class="n">setup</span> <span class="p">(</span>
</span><span class='line'>  <span class="n">name</span><span class="o">=</span><span class="s">&#39;fantomlexer&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(),</span>
</span><span class='line'>  <span class="n">entry_points</span> <span class="o">=</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd"> [pygments.lexers]</span>
</span><span class='line'><span class="sd"> fantomlexer = fantomlexer.lexer:FantomLexer</span>
</span><span class='line'><span class="sd"> &quot;&quot;&quot;</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>There is that pygments.lexer entry point! It points to the module fantomlexer (directory for the <code>lexer.py</code> file) dot lexer (the source file with the lexer class inside) colon FantomLexer - the acutal lexer class inside the <code>lexer.py</code> file.</p>

<h2>Installing the entry point module</h2>

<p>Python modules can be either installed as an egg - or simply linked in as a file link. I recommend using the file link style since you can then iterate by simply editing the <code>lexer.py</code> file instead of having remember to run install every time.</p>

<p>Open up a terminal in the FantomLexer directory and type:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo pyhton setup.py develop
</span></code></pre></td></tr></table></div></figure>


<p>To verify that its there type <code>easy_install</code> and it&#8217;ll print an error message telling you what folder the eggs are installed on your machine. On mine its in <code>/usr/local/lib/python2.7/dist-packages/</code>. Cd into that folder - there should now be at least two files (and one folder with Pygments egg installed previously) - <code>easy-install.pth</code> and <code>fantomlexer.egg-link</code>. List the content of <code>easy-install.pth</code> and verify that there is an entry pointing to your FantomLexer folder created above.</p>

<p><code>lexer.py</code> is now ready to parse your code into tokens. A quick start is to copy some already existing lexer close to your language and tweak it. To get a highlighted file with your new syntax type:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pygmentize -f html -O full Testfile.fan &gt; temp.html
</span></code></pre></td></tr></table></div></figure>


<p>And view the results in a browser.</p>

<h2>Python knowledge disclaimer</h2>

<p>This is one of my first close contacts with python so take this guide as a newbie trying to lead other newbies through the process. If you are a python aficionado and see some way of improving this please let me know in the comments. Thanks.</p>

<h2>Ubuntu sided disclaimer</h2>

<p>Also, I&#8217;m running ubuntu so this guide will be using ubuntu paths and default setups. I&#8217;m hoping it shouldn&#8217;t be too hard to convert to other distros (or even OS&#8217;es). I&#8217;m assuming python is installed on your box.</p>

<p>All of the commands above uses sudo as ubuntu apt-get needs sudo - and from there it just cascades, but there is an alternative using <a href="http://www.virtualenv.org/en/1.9.X/#what-it-does">virtualenv</a> (similar to rvm) that you can run with your own user instead of root.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stages of a code review]]></title>
    <link href="http://jonaslu.github.com/blog/2013/02/24/stages-of-a-code-review/"/>
    <updated>2013-02-24T21:00:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/02/24/stages-of-a-code-review</id>
    <content type="html"><![CDATA[<p>My team at work have been doing code reviews for about 2 years now. Its gotten to the point where I&#8217;m actually a bit
surprised and disappointed if I don&#8217;t get &#8220;I&#8217;d prefer you&#8217;d not submit this&#8221; with some questions or comments.</p>

<p>Code reviews are four wishes in one really: quality assurance (this is a no brainier), replicating knowledge throughout the team,
a great learning tool and educational tool and finally - this is probably the most important one - it&#8217;s a great
synchronizer of product vision and architecture (i e where are we going with this and how does it look when we get there?).</p>

<p>In the acadmic world all teams go through <a href="http://en.wikipedia.org/wiki/Group_development">4 phases</a> when forming:</p>

<ul>
<li>The formal phase</li>
<li>The ugly phase</li>
<li>The solving phase</li>
<li>The constructive phase</li>
</ul>


<p>Introducing code reviews on my team went through roughly the same 4 phases. I&#8217;ll walk you through its incantations - (and yes, the phases have been amped up a bit for dramatic effect).</p>

<h2>The formal phase</h2>

<p>Everyone is nice and lets too much ugly stuff pass (others code of course) but underneath the surface the tension is growing. Flames starts to erupt more and more and we transition into&#8230;</p>

<h2>The ugly phase</h2>

<p>The guns come out blazing. Knit picking and overly zealous code reviews. Rages through restrained comments.
The focus is usually myopic - variable prefixes, should all parameters be final, checked vs unchecked exceptions etc with an all or nothing approach. Some will try to quiet this phase by calling for &#8220;review documents&#8221; and &#8220;standards&#8221;. Books are scoured, internets are searched for an acceptable formal definition and ingredients of a code review. Do resist that urge - I&#8217;ll get to why in the end of this post.</p>

<p>A word of comfort for the poor souls in this phase - this is good. Stay with it. Your team is feeling concerned for the code, but the concern is a bit misguided at superficial things. Use this
to focus on the real concern - architecture and the great product you&#8217;re supposed to be building. Use the discussions as a
setup for getting to the how and the why on a larger scale.</p>

<p>Let the gloves come off and let them stay off until the discussion gets constructive. It&#8217;ll pay off.</p>

<h2>The solving phase</h2>

<p>We&#8217;re not out of the woods yet, but we&#8217;re starting to move in the right direction. Egos are starting to subside and the other side is listened to. Its not yet a fully constructive dialogue but at least other arguments besides your own are heard. Use this to move forward.</p>

<p>Try to get to the root cause of the discussions. Chances are you have technical debt and the code is not where you want it to be. Your vision in the team is not in sync. This will show up in code reviews. Call it
teamnical debt (clever huh?). Code and approaches are not being discussed enough so everyone has their own view of what you&#8217;re building and how to build it.</p>

<h2>The constructive phase</h2>

<p>How did we get here from the last phase? By getting to the root cause of the discussions I&#8217;m hoping everyone starts noticing that we all want the same end result - the best product ever made by man. Its just diffrent approaches to this. Its no longer about beeing right, its about generating the best approach and&#8230; well, just getting things done really.</p>

<p>You&#8217;ll be very happy that you didn&#8217;t settle on some &#8220;formal review standard&#8221;. Its easy to get caught up in trying
to control the growing flames but this will also take away from the end result - no document can ever substitute judgement of each particular case. The end result is the ability to discuss architecture and code structure.</p>

<p>This also the most relaxed place. The micro-concern of syntax and formalia are replaced with the macro-concern of building a great product.
Its more pragmatic and constructive. Quality is everyones concern.</p>

<h2>Y u no fail review?</h2>

<p>So how do you know where your team is on that scale? In my book if reviews are failed more often than they are approved but everyone is still smiling you&#8217;ve nailed it. Its that nice place where you appreciate someone elses comments and look forward to getting them to improve your code - make it more readable, fix some bugs when they&#8217;re still cheap to fix or align your vision of the perfect product.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fantom the language]]></title>
    <link href="http://jonaslu.github.com/blog/2013/02/18/fantom-the-language/"/>
    <updated>2013-02-18T21:22:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/02/18/fantom-the-language</id>
    <content type="html"><![CDATA[<p>I&#8217;ve been working on the JVM for about 4 years now. Its been a pleasant ride so far but lately I&#8217;ve started to outgrow Java. The JVM platform is brilliant in itself. The speed is almost on par with native code, its easy to install and get an app running - there&#8217;s plenty of tooling and performance monitors for it. Its stable and mature, has a large user base and it runs on many platforms (really the top reason for staying with it).</p>

<p>But Java the language feels a bit dated. Or rather, once you start looking at more current languages with a functional edge and other goodies - it&#8217;s hard to go back and doing that stuff manually. Granted, Java 8 seems to be getting some of these features like closures and lambda expressions. But there still will be plenty of things to miss given its rather verbose syntax and constructs.</p>

<p>There is a current upsurge of languages building on the JVM - with Scala and Clojure getting the most love. I&#8217;ve tried Scala but eventually had to abandon and move on - the hunt was on for a new language.</p>

<h2>Enter Fantom</h2>

<p>It was actually <a href="http://www.devoxx.com/display/DV11/Is+Fantom+light+years+ahead+of+Scala">this</a> presentation of <a href="http://blog.joda.org/">Stephen Colebourne</a> that peaked my interest.</p>

<p>Written by Brian and Andy Frank for their own company <a href="http://skyfoundry.com/">Skyfoundry</a> after trying on different languages for their new company (more on why <a href="http://fantom.org/doc/docIntro/WhyFantom.html">here</a>).</p>

<h2>The pros</h2>

<p>(Super) readable syntax. My #1 reason. If you know Java or C# with just a hint of Ruby you can pretty much be productive right away with less typing.</p>

<p>Multiline strings and string interpolation. Probably my #2 reason. The whole templating deal in Java is largely a solution to this problem. There is going to creep in  HTML in the code, and it might as well align and read nicely.</p>

<p>Built in make- system complete with versioning of dependent libs. I&#8217;ve spent too much time on several languages at the setting up a project phase. Breaking backwards compatibility is tends generate a chicken race where everyone waits for someone else to upgrade to the latest and greatest. In such languages using external libs quickly becomes a trial and error of what versions you can run against what language version (and usually the make tool also is versioned against those libs and the language). In fantom you clearly state in your pod (think of it as a versioned lib) what libraries and what versions of those libraries you depend on. The make tool is built in so its compatible with the release you&#8217;re running. You&#8217;ll even get a compile error if you try to use a class in a pod which you have not declared as a dependency.</p>

<p>Type system built for reflection. I tend to stay away from reflection in Java because it introduces too much magic in the code. Refactoring code always feels a bit uneasy because you don&#8217;t know if someone reflectively invokes that method or class you just removed. It&#8217;ll show up in production at the worst time of course. In fantom you&#8217;ll get a compile time error if your reflective type is missing.</p>

<p>There&#8217;s plenty of dogfooding. One concern many seem to have is that its relatively unknown and unused. Skyfoundry was based on their own language so its being used in production by its own authors. The authors are betting their own company on this language - so its actually backed by a corporation already. There are some replies in <a href="http://fantom.org/sidewalk/topic/1978">this thread</a> to that concern.</p>

<h2>The cons</h2>

<p>IDEs support. This is not a bash on the editors out there (f4, netbeans plugin and some text editors) - its just that being on the JVM you&#8217;re gonna get compared to eclipse or netbeans. And compared to these they are still lacking - again lots of hard work has been put into these editors so its not a fault of their respective authors. Its just a little hard getting used to after such stellar IDEs in Java.</p>

<p>Its a bit quiet. The community is great and helpful but its still moving rather slow for such a mature (and great) language. I&#8217;m hoping more converts show up and make the community a bit more vibrant.</p>

<p>Not that many libraries. Goes hand in hand with the quiet community. There is a CPAN / gem / maven central style repo tool build into the language. But the default address in <a href="http://fantom.org/doc/fanr/index.html">fanr</a> still goes nowhere. <a href="http://wiki.colar.net/">Thibaut Colar</a> has been kind enough to host a repo in the meantime (found <a href="http://repo.status302.com/">here</a> including instructions on how to use it). Also not all frameworks are in that repo. They are scattered across bitbucket and github with no real way of finding them, save for searching the forum, bitbucket and github. Again, more converts means more libs so its a matter of bootstrapping both the community and the libs.</p>

<p>Examples and snippets of how you do things. The documentation is quite very detailed - but as soon as you hit the code there is all those small cases that are not covered. In the begining you will probably write java code with fantom syntax. There are a lot of gems and small shortcuts that make more idiomatic, buts its much a trial and error way there. The distribution does ship with the entire source and its a great source for idiomatic code - but its a heavy digest if you&#8217;re not into compiler construction.</p>

<h2>The whys</h2>

<p>I&#8217;m a sucker for good engineering trade-offs. I really like how fantom focuses on getting work out the door. Its shuns the extremes and often takes the &#8220;middle road&#8221;. I love this kind of stuff - it just spells good engineering to me.</p>

<p>One thing that&#8217;s been hitting me a lot when doing some code is how often I started out doing something - only to find out that there&#8217;s already method for that. Compact as the API may be this again seems like the authors knowing what will be useful to put into the API. This makes it a gem to code with, much less manual stuff than a quick glance may reveal.</p>

<p><a href="http://fantom.org">Now go! Try it.</a> I&#8217;ll be writing more on it here in coming posts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup]]></title>
    <link href="http://jonaslu.github.com/blog/2013/02/08/setup/"/>
    <updated>2013-02-08T20:55:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/02/08/setup</id>
    <content type="html"><![CDATA[<p>Before getting on with writing posts props needs to go to the people and software that made this possible. The background texture was found <a href="http://designmoo.com/16245/technical-drawing-paper-texture/">here</a> by <a href="http://www.peweedesign.com/">pewee design</a>. The header font from <a href="http://www.dafont.com/candy-inc.font">here</a> by <a href="https://www.facebook.com/billyargelfonts">Billy Argel</a>.</p>

<p>This blog runs on the awesome framework <a href="http://octopress.org">octopress</a> and of lots of coffee. The theme is an adaption by me on the defualt theme shipped with octopress.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World!]]></title>
    <link href="http://jonaslu.github.com/blog/2013/02/05/hello-world/"/>
    <updated>2013-02-05T21:17:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/02/05/hello-world</id>
    <content type="html"><![CDATA[<p>Phew, just had to get that off my chest. It has been brewing for a couple of years now.</p>

<h2>And who are you then?</h2>

<p>Hacking stuff started at an early age - writing basic on an old 286 (no scoffing! It had an extra math co-processor chip thank you very much). Mostly because I wanted to see what I could make the computer do. Since then some education before now having worked in the software industry for about 7 years now on several different sites. First as a consultant before landing at my current workplace as a  software developer and part time team lead.</p>

<h2>Why write this blog?</h2>

<p>As with any topic, first stage - learning the craft, second stage - actively employing it and third stage - starting to contribute and setting out to bring the field forward. This is one of those outlets, where hopefully I can contribute in some small way to the advancement of the craft.</p>

<p>Nothing evolves in vacuum. The greatest ideas are usually juxtapositions of other great ideas. I&#8217;ve been continually amazed at what people can come up with - its never just the sum of the parts. So hopefully this will go the same way, ideas bouncing off each other building something greater than the individual parts.</p>

<p>So the bar is set aptly high, all needed now is just producing content.</p>
]]></content>
  </entry>
  
</feed>
