<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: languages | Catch me code]]></title>
  <link href="http://catchmecode.com/blog/categories/languages/atom.xml" rel="self"/>
  <link href="http://catchmecode.com/"/>
  <updated>2013-09-22T21:54:26+02:00</updated>
  <id>http://catchmecode.com/</id>
  <author>
    <name><![CDATA[Jonas Lundberg]]></name>
    <email><![CDATA[jonasl@catchmecode.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The next big language]]></title>
    <link href="http://catchmecode.com/blog/2013/04/24/the-next-big-language/"/>
    <updated>2013-04-24T21:57:00+02:00</updated>
    <id>http://catchmecode.com/blog/2013/04/24/the-next-big-language</id>
    <content type="html"><![CDATA[<p>This is a hot topic, there&rsquo;s no shortage of blog posts already. So all the reason for me to join in and throw my prediction in the pile.</p>

<p>But first a trip down memory lane. The first language used in teaching I encountered was <a href="http://en.wikipedia.org/wiki/Pascal_(programming_language%29">Pascal</a>. The more I&rsquo;ve thought about it the more it stands that this was for a good reason. Pascal had strictness on form built into the language. Turns out this even had a name wich I didn&rsquo;t know about &ndash; <a href="http://en.wikipedia.org/wiki/Structured_programming">structured programming</a>.</p>

<h2>Why Pascal was used</h2>

<p>There was more to Pascal besides the actual mechanics of programming &ndash; to emphasize structure and form. In the small you were given your first lesson in how to successfully communicate your ideas through code. Most probably this was only to your teacher for passing the assignments or for your future self revisiting the code some months down the line. But it was an important first lesson.</p>

<h2>Java/C# is the Pascal of the industry</h2>

<p>The much cursed verbosity of these languages are actually IMHO their reason for making it as an industrial language. They force you to flesh out more on your intent and expose more details (that&rsquo;s where the devil hides) of your ideas. More typing for you &ndash; but more benefits for the large team or corporation.</p>

<p>I think this is why javascript is having a resurgence and why node.js has been so successful &ndash; the introduction of the module pattern and that variables and functions are hoisted to the top of each function. It&rsquo;s really a blessing in disguise because you&rsquo;re now forced by <a href="http://en.wikipedia.org/wiki/Douglas_Crockford">Crockford</a> via <a href="http://www.jslint.com/">jslint</a> to declare variables in the top of the function. This helps clear up intentions. Same goes with the module pattern. You&rsquo;re more bound to one common form and others can more easily spot what you&rsquo;re trying to convey.</p>

<p>Java has this built in &ndash; you&rsquo;re forced to follow a pretty strict pattern when writing code. Perl does not and I&rsquo;m thinking this is why it hasn&rsquo;t been used that much for large projects despite being around for so long. Its good for the one-off scripts that you and a few of you&rsquo;re colleagues on the same team will read. But if you scale it up &ndash; there&rsquo;s <a href="http://perl.plover.com/obfuscated/">too much freedom</a> or rather too much room for personal style. Ideas will be hard to convey unless everyone agrees on a formal standard and what better way to enforce a standard than built into a language?</p>

<h2>The form should help collaboration</h2>

<p>Every new programming language that&rsquo;s coming out is touting type less get more done as its main selling point. Its an amicable aim to reduce the amount of code having to be written since bugs tend to correlate with the lines of code. There will be abundant examples of how you can write this or that problem in so few lines of code compared to that language. All good so far, its got to start somewhere and you the programmer is its main target for adoption.</p>

<p>But how few lines of code you can write something isn&rsquo;t really a good gauge of a new language. How well someone can understand your intent of the code you wrote is much more so. Remember that you&rsquo;re seldom writing code for yourself but most of it for others (or your future self that tends to forget what that so compact one liner really meant).</p>

<p>This has to be if not more important than at least as important as reducing the lines of code. The reduction should only be made if the intent and message is still as clear sans the lines reduced.</p>

<h2>The next big language</h2>

<p>My bet is that it will be strict on form and structure. It maybe will reduce the lines of code somewhat, but not by as much as you&rsquo;d hope for &ndash; because transparency cannot be sacrificed for terseness. It just won&rsquo;t work across larger code bases and teams.</p>

<p>I think it won&rsquo;t be decided by you the programmer as much as it will be decided by teams trying to get stuff done. In true pragmatic fashion lanugages that do not convey the message clearly enough will be thrown out in favour for languages that do. Call it democracy by pragmatism.</p>
]]></content>
  </entry>
  
</feed>
