<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: productivity | Catch me code]]></title>
  <link href="http://jonaslu.github.com/blog/categories/productivity/atom.xml" rel="self"/>
  <link href="http://jonaslu.github.com/"/>
  <updated>2013-08-01T22:16:21+02:00</updated>
  <id>http://jonaslu.github.com/</id>
  <author>
    <name><![CDATA[Jonas Lundberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast programmers]]></title>
    <link href="http://jonaslu.github.com/blog/2013/07/15/fast-programmers/"/>
    <updated>2013-07-15T22:25:00+02:00</updated>
    <id>http://jonaslu.github.com/blog/2013/07/15/fast-programmers</id>
    <content type="html"><![CDATA[<p>The legend has it that the best programmers are a <a href="http://www.construx.com/10x_Software_Development/Productivity_Variations_Among_Software_Developers_and_Teams__The_Origin_of_10x/">magnitude better than the average one</a>. Having worked with some that I'm suspecting (or at least hoping so the rest of us mortals have some chance left :) would be in the top echelon I've tried to draw wisdom from these people on what makes a really fast programmer.</p>

<p>Lets start with some rampant stereotyping into two categories!</p>

<h2>The fast but sloppy</h2>

<p>These are only seemingly fast. They tend to push work (although I think its unintentional) onto others thereby making them look fast. The speed comes from skipping on tests and edge cases. Some might even appear to be superhuman since they would be in the top bracket even if they would take the time to make their code high quality.</p>

<p>The thing is that the work they're supposed to do winds up at other peoples desks in forms of bugs and hard-to-impossible to read code. So the amount of work you save on one guy is just moved (and multiplied by the amount of people) to another place. Unfortunately its very hard to track and prove. Bugs might not appear for months and unmaintainable code takes considerable time to surface and rear its ugly head.</p>

<p>These are not what I consider fast. These are only fast by omission.</p>

<h2>The fast and precise</h2>

<p>This is the recruiters pot of gold. The really fast but also precise and annoyingly almost always right. How do they do what they do?</p>

<p>This is purely from what I've seen myself watching these guys in action. I've tried to interview some that I would consider being in this category - but I'm guessing its a bit like asking Picasso how to paint: "Uh, dude .. just grab a brush and go" (In my head this is exactly how Picasso would reply :) - the replies didn't reveal much. So with those replies I've gathered that its not something that's intentionally being turned on or done on purpose. Its seems almost as a reflex.</p>

<h2>Insane focus</h2>

<p>This is the first and probably most important point. An absolutely unwavering focus. Everything but the problem at hand is secondary.</p>

<p>If you spend 5 minutes on youtube or twitter you know you've lost 5 + about 15 minutes (in context reset mode). Multiply this by the productivity of really good programmer and you've lost considerable distance already. By just zoning off for 5 minutes.</p>

<p>Not everyone can keep this focus as I've seen these guys do. I'm guessing its part built-in and part having the right tasks. But I do think that focus can be trained far more than what most have built-in.</p>

<p>This does not mean take no breaks. Do take breaks if you're getting unfocused. We all have diffrent limits for how long we can keep at it. But here's the kicker - take a break only after you've had a good productive run. Not before or during - because then there will be no productive run.</p>

<h2>Iterate faster</h2>

<p>Armed with the unwavering focus is a just as unwavering will to move forward. I mean move forward as in get your hands dirty. A <a href="http://www.codinghorror.com/blog/2004/09/development-is-inherently-wicked.html">wicked problem</a> is a problem that cannot be solved until it has been solved. And I agree with the link - most software development problems are inherently wicked. You just have to try stuff until you find a way that works (note: not the right way - the fastest working way will do just fine).</p>

<p>This means not overengineering solutions or <a href="http://catchmecode.com/blog/2013/06/15/bug-repellants/">setting breakpoints on a bug right away wihtout speculating first</a>. Get data and experience just enough solve the problem here and now. Tomorrow everything will change anyway - just go, start trying out solutions. The faster you can try it out - the faster you can discard it and move on to the next. And it has to be done in practice at the keyboard.</p>

<h2>Produce more</h2>

<p>This ties in with all of the above - <a href="http://sivers.org/qlq">the more you produce the better and faster you get at it</a>. The fast programmers produces more code because they've already produced more code. The gap widens.</p>

<h2>What to do with this?</h2>

<p>Cultivate focus. Mediation is said to <a href="http://www.time.com/time/health/article/0,8599,2008914,00.html">help</a>. Try that. But first and foremost - try to get interested in what you do right now and ignore the rest of the world. Really sink into it. <a href="http://catchmecode.com/blog/2013/03/16/boredom-the-hidden-asset/">Use boredom</a> to lead the way.</p>

<p>Try to get more interesting tasks. This way, having focus might not be so hard. If you're a good programmer - chances are you'll get to pick tasks and assigments earlier and earlier thusly getting the goodies first. So it spirals upwards - you keep focus and produce more because you get more interesting tasks.</p>

<p>Cultivate fearlessness and pragmatism. Try something. Didn't work? Good, now you know. Now try something else (i e iterate faster - get more experience on the problem, the domain and your tools).</p>

<p>Don't confuse sloppiness with being fast. This is the dark side of the force. Don't go there... it will catch up with you.</p>

<p>As said, this seems to be built-in for most of the fast programmers I've talked to. But that does not mean you should stop trying to emulate that - au contraire! If practiced enough it might become second nature to you too..</p>

<p>And all of this is summarized in the words of my imaginary Picasso: "Uh, dude.. just grab the keyboard and go".</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bug repellants]]></title>
    <link href="http://jonaslu.github.com/blog/2013/06/15/bug-repellants/"/>
    <updated>2013-06-15T22:48:00+02:00</updated>
    <id>http://jonaslu.github.com/blog/2013/06/15/bug-repellants</id>
    <content type="html"><![CDATA[<p>I've seen this go down a fair amount of times - myself included. I just know why its happening, right. Its this damn line here - there is something with this function call. Change it a bit at random, run a test, see it fail. Why in the name of S is this still failing? Change some more at random - google what I <em>know</em> is the problem - see it fail again. Sounds familiar, right?</p>

<p>My biases on where the problem was and what caused it has cost me a fair of amount of time wasted. Its also the greatest hurdle to get past (since your ego is involved). About 90% of the time if I don't solve the bug in 30 seconds - its not the cause I thought it was. It usually turns out to be something very different. And the way to get from here to there is to let go of whatever cause you had pictured in your head.</p>

<h2>Get verifiable data</h2>

<p>The first step is to free yourself from whatever you think of the bug. Its crucial to keep all options open and then narrow down on the causes and fixes. Take a step back (and some fresh coffee), free of your biases and look at the situation. You need some kind of data to work with. Just guessing at random will not help you (has it ever really?).</p>

<p>I'm fairly reluctant to label the bug too specifically in order to remind myself that it might not be what I'm looking for. Rattling of a "oh, its a threading issue" too soon might cut you off from the real cause. Perhaps its not a threading issue at all - it just looks like it from a distance.</p>

<h2>Ground zero</h2>

<p>First step - where does it occur? In some cases such as an exception, its obvious where it occurs. Or is it? What if its an exception caught and rethrown silently? Go to the line and look at it. Make sure you're looking at the right line.</p>

<p>Can you get it to fail each time? Can you set up some scaffolding to get it into the fail-state? Are you sure its only here? Are there any other paths to where it seems to occur? Can you do some auxiliary small tests to verify that its really where you think it is?</p>

<p>You need to make sure you're looking at the right neighborhood. If its vague - acknowledge that its vague so you don't get the wrong impression of knowing where to look. Avoid labeling it.</p>

<h2>Breakpoints</h2>

<p>For zeroing in on bugs that you don't know where they fail - but you now can reproduce the failure each time - breakpoints is an indispensible tool.</p>

<p>If your language supports debugging via breakpoints - good for you :) If not, use good 'ol print statements. Put a breakpoint far enough up in the call stack so you don't miss it (unless its a very specific error, such as a NullPointer - then you can set a breakpoint on the NullPointer exception itself and work backwards).</p>

<p>What does the state look like when the bug occurs? The stack trace? Can you go up the stack trace to see who called you and what their state looked like? Can someone else in turn affect the one calling you and so on? Can you compare this state with a stable state you know does the right thing?</p>

<h2>Change state</h2>

<p>If your language and tool supports changing values while hanging on a breakpoint - can you change some parameters to get it working? Can you inspect the state of the variables and the stack trace of what got you there? Is there any other way to get here or affect the state you're currently looking at? If not, use simple assignments along the way to affect the state.</p>

<p>Input other data than what you normally put in. Does it still fail? Can you alter the code path so it works?</p>

<h2>Last known stable state</h2>

<p>Next step once you have established where it occurs is to have something to compare it with that you know works / is right. Is there one? If so, can you revert to it (you did commit did you not?). Start from there and trace forward to where the bug was introduced. If you use git - <a href="https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html">git bisect</a> was done for this.</p>

<p>Can you compare some logs, files, state, stacktrace of when it works the way you want it to? Can you do some auxiliary experiments to get a working stable state to compare with?</p>

<h2>Git blame</h2>

<p>Why is it here? What's the surroundings of the bug? Can you get some historical facts on why it looks like it does? Has there been much action in this area lately (or things that are related to it?). Does the commit message give you some hints on why?</p>

<p>Just knowing when it was introduced (around what time) may give you hints as to what else was going on at that time what might have caused it. Another useful thing is that it might be a bug that someone now relies on. So its actually more of intended (incidental) behavior. Check that if you do fix this nothing else breaks.</p>

<h2>Read up</h2>

<p>This comes fairly low on the list because it should be used with caution. Its very easy to get distracted and mislead by seemingly similar problems that others might have. Do check - but take everything you read with a big pinch of salt. Keep in mind that you're reading the textual representation of their interpretation of the problem. Maybe they haven't gone through the same thorough investigation you just had (you did get verifiable data, right? :).</p>

<p>When using some someone elses library its more useful - after you've established that the problem is in someone elses library. Has someone else had a similar problem? If so - how did they solve it? If not - how probable is it that you're the only one in the world experiencing this? That last part is aimed at stopping the "its a bug in the OS" type of answers. If its an OS its very well used and thusly its very probable its an already known bug - and if not it's probably in your code. Not theirs.</p>

<p>What does any documentation say? Have you made the right assumptions? Is there any pre-cond you're not aware of? Are you using it the way its meant to be used? Can you get the source for whatever you're looking at (and start from step #1 again above, this time in their code base?)</p>

<h2>Questions?</h2>

<p>This post came off more as a huge pack of questions than I originally had planned - but then again, this is usually how (successful) debugging sessions go. A huge amount of questions thrown around to establish where, why and finally how to fix it. Its by no means exhaustive as every bug and every situation is a bit different. These are just the main tools I usually go for when facing an unknown problem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phone meetings]]></title>
    <link href="http://jonaslu.github.com/blog/2013/05/10/phonemeetings/"/>
    <updated>2013-05-10T21:52:00+02:00</updated>
    <id>http://jonaslu.github.com/blog/2013/05/10/phonemeetings</id>
    <content type="html"><![CDATA[<p>This happens often enough to qualify for a post. Phone meetings. The one where you call in to synchronize some process or project. My workplace does a fair amount of integrations (i e sending data from us to them or vice versa) that this is a real problem. As an agile team, no wait, strike that.. as a team who like to get stuff done have to fend ourselves from spending too much time in those.</p>

<p>Lets delve into this a bit, shall we?</p>

<h2>Background</h2>

<p>Let's clarify first - I'm all for keeping close contact (if needed) and synchronizing schedules. This is pivotal to meeting the integration deadline. Its very dissatisfying to really push through an integration only to find out that the other side is not nearly done. Your code will be in a vacuum until they start testing their pieces and you'll have to go back and fix all the tings uncovered during their test phase. Nope, it's about the medium (phone) and the scheduling (not governed by technical needs).</p>

<h2>4k bandwidth impediment</h2>

<p>Software, data-exchange formats and the likes are no pick nick doing in person. I know that if we have a whiteboard it'll take some time to understand each other, and another chunk of time to get a solution in place. Imposing an artificial impediment such as no visual information and only 4k of bandwidth (fixed phone lines) makes little sense coming from a technical perspective.</p>

<p>I understand that phone is the second best medium for dealing with human relations - but in technical discussions where the objective is to flesh out the details of a transfer format or what webservice port we're using its maybe the nth best medium. Way superior is something visual - such as mail and or lo-fi snapshots of whiteboards - details needs to be in writing.</p>

<h2>Imposed scheduling</h2>

<p>A first meeting is ok - preferably a short one where we say "I'm Jonas  - a developer. I'll be handling the integration from our side. Oh, you're using .NET? Ok, good to know for webservice quirks and BOM characters. Now, can we go offline and do the rest via mail? Great, nice talking to you all, we'll keep you updated on the progress". We are humans after all and a voice and a name goes a long way in better cooperation.</p>

<p>But really, more than that first startup meeting is rarely a good use of time. Now, this is highly dependent on the project manager on the other side. If we're lucky, they are ok with an on a need to know basis - i e when we hit cases not covered by specs. Most of the time though there are meetings scheduled more out of management needs - e g a status meeting 1h each week to follow up on anything that happened last week. I like to think of these meetings <a href="http://simpsonswiki.net/wiki/Everything's_OK_alarm">the everytings ok alarm</a>. Or worse, those weekly meetings plus a new meeting anytime a mail even mentions the words problem, bug, issue or the likes.</p>

<p>This gets in the way of producing code - problems rarely align to weekly meetings and weekly meetings are rarely interesting in full to all parties involved.</p>

<h2>They are not stupid</h2>

<p>As said from the outset this might seem outlandish to an agile small team - but lets consider context. I'm guessing it makes very much sense in other organizations to have many and recurring meetings. It may be a large corporation where this is the only way managers can keep up with how the project evolves. Being small and agile largely cuts this out. Also consider that many things that seems stupid now started out as being helpful (TPS reports etc) only to later evolve into something that may not be so helpful now - except that there is no better alternative. Or that none dares to go differently.</p>

<h2>You might be the weird one</h2>

<p>At many places things don't happen because someone says so - things happen because there are follow up meetings and agendas. Trying to get out of meetings might signal that you're work shy. Explain very thoroughly how you work and what you will deliver at what point in time.</p>

<h2>You might be a tiny part of it</h2>

<p>Sometimes its hard to gauge the size of the project on the other side. You might be a tiny part in the whole - it's just that its not apparent. The file you are sending their way might be processed in 15 different systems and all of them needs to implement this new feature. You'll be spending lots of time listening to their issues and scheduling synchronizations. This is not in defense of huge meetings - but its often a reality and might be of some comfort when trying to understand why there are 10 people in this meeting when you are sending 1 file.</p>

<h2>Eject early, eject often</h2>

<p>There is hope however. It may not have to be like this, or it can at least be brought down to a lesser level:</p>

<h2>Inversion of control</h2>

<p>In the initial meeting, try to figure out who's the key technical person on the other side. Get their mail (and phone number if needed). If you're lucky you can go straight to that person and most things never have to escalate beyond you two (except when it actually is a problem for the whole project). The technician on the other side might be interested in this too - most coders face the same problem with tech specs over phone and meetings gets in the way of producing code.</p>

<p>And if no one seems to be the key person - try to see if someone gives you coherent and intelligent answers. Maybe they can point you in the right direction. Mail only the person you think know have the answer, avoid cc:ing lots of people (unless you've promised some project manager to cc your conversation. Include only them in that case). Mail threads tend to accelerate the number of people on the send list fast and if it grows big enough it might trigger a new meeting.</p>

<h2>Get a goal keeper</h2>

<p>This should ideally be your project owner or someone who carries enough weight that if they say "we're doing fine" - its assumed you're actually doing fine. This person participates in any weekly status meetings on your behalf. Send him a status report saying "we're ok" (if you're ok) and ask for condensed information that pertains you (it's usually very little). The product owner might be interested in covering for you since its project time spent in meetings that could have been used more wisely.</p>

<h2>Round robin the role</h2>

<p>If none of the above works - share the burden. You're doing a good thing - freeing up the rest of the team to get some work done. They'll get a good laugh when you roll your eyes and do the talking hand motion - and they'll probably back you up with videos of funny cats and capybaras to ease your pain. And next time you're off the hook.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boredom the hidden asset]]></title>
    <link href="http://jonaslu.github.com/blog/2013/03/16/boredom-the-hidden-asset/"/>
    <updated>2013-03-16T21:50:00+01:00</updated>
    <id>http://jonaslu.github.com/blog/2013/03/16/boredom-the-hidden-asset</id>
    <content type="html"><![CDATA[<p>I've been fighting boredom and procrastination for as long as I can remember.</p>

<h2>Boredom on personal projects</h2>

<p>Ah, new stuff. Fresh, untouched, exciting - and safely without practical use. Boredom and procrastination usually sets in when the first road block is hit. Like actually writing lines of code in that new language. Or using the long researched best web framework. And it results in more research and more looking at new things. Seldom staying long enough with something to make it useful.</p>

<h2>Moving is not a solution</h2>

<p>Same went for my workplace - I'd be all over it the first few months or even up to a year or two. Then when progression started to slow down - I knew the sites and the layout of the code its shininess faded and - hello boredom again!</p>

<p>Previously working as a consultant this didn't turn into a problem since I changed workplaces often enough to keep things new and fresh. But this wasn't really a solution on the problem, it was simply running away from it.</p>

<h2>Neither are processes</h2>

<p>So, true to engineer fashion I looked for remedies in the shape of processes and tools. I tried task lists, pomodoro, time boxing to name a few. This usually started out well but when the new effect wore off - about the same or more procrastination. And in the back of my mind I couldn't help but think that all of those processes seemed too rigid. It was forcing it.</p>

<h2>Blog post to the rescue</h2>

<p><a href="http://99u.com/articles/7188/why-boredom-is-good-for-your-creativity">This hit me like a two ton heavy thing</a> (yes there's probably some irony in finding the solution out there in a blog, the siren song of procrastination). To sum it up: It's ok to be bored. In fact - if you're bored and it's the right kind of bore you are on to something big.</p>

<h2>Preparing to climb</h2>

<p>So I decided to work it. To leverage boredom instead of trying to suppress it.</p>

<p>The setup was this: close all the usual suspects. No mail notification icons, no rss feeds, no open  applications except for the minimal amount really needed to get the work done. Don't minimize the windows. Close them. Deinstall what you can. You need to implement it the hard way and really maximize the potential for boredom.</p>

<p>Now sit there and let the boredom set in. Look at the code, stare at it. Don't leave your workplace for anything less than critical. Do not open any mail clients or the likes. Gorge on boredom... and waaaaiiit for it.</p>

<h2>Downhill sunny side</h2>

<p>Past this point was a bit like that monkey meeting Jane Goodall. She just stood there and didn't run away. What now?</p>

<p>Turns out boredom is a hill you're meant to climb. The steeper the climb up, the sweeter the ride down. You eventually start to tinker in small pieces. And then in larger pieces, and before you know it you're totally emerged in what you wanted to avoid.  Beyond that hill of boredom is the pot of voluntary productiveness.</p>

<p>On this side you'll be glad you deinstalled all those notifiers and closed all those windows with sweet sugary distraction. You're in the productivity zone cruising - but it's a fragile zone. Any  distraction will break your concentration and you need to go through the build up phase again.</p>

<h2>Boredom as an innovator</h2>

<p>Here's a bonus I didn't see coming from this. When hitting boredom full on and closing down the distractions you get annoyed by manual and slow things. You know, the build window where you'd check your twitter account only to notice the build finished 15 minutes ago. Those hurt much more now because you're now in productive mode after being bored you don't want to go back - so you automate and innovate to minimize the mundane and time consuming parts.</p>

<h2>Switched tables</h2>

<p>Wow. How's that for a flip side? Turns out boredom is not a liability - it's an asset. And a valuable one at that. Its your personal indicator of how much you're going to enjoy the task once the resistance subdues.</p>
]]></content>
  </entry>
  
</feed>
